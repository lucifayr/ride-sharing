// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: rides.sql

package sqlc

import (
	"context"
	"database/sql"
)

const ridesCreate = `-- name: RidesCreate :one
INSERT INTO
    rides (
        location_from,
        location_to,
        tacking_place_at,
        created_by,
        driver,
        transport_limit
    )
VALUES
    (?, ?, ?, ?, ?, ?) RETURNING id
`

type RidesCreateParams struct {
	LocationFrom   string `json:"locationFrom"`
	LocationTo     string `json:"locationTo"`
	TackingPlaceAt string `json:"tackingPlaceAt"`
	CreatedBy      string `json:"createdBy"`
	Driver         string `json:"driver"`
	TransportLimit int64  `json:"transportLimit"`
}

// See sqlc docs for more information:
// https://docs.sqlc.dev/en/latest/tutorials/getting-started-sqlite.html#schema-and-queries
func (q *Queries) RidesCreate(ctx context.Context, arg RidesCreateParams) (string, error) {
	row := q.db.QueryRowContext(ctx, ridesCreate,
		arg.LocationFrom,
		arg.LocationTo,
		arg.TackingPlaceAt,
		arg.CreatedBy,
		arg.Driver,
		arg.TransportLimit,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const ridesCreateEvent = `-- name: RidesCreateEvent :exec
INSERT INTO
    ride_events (
        ride_id,
        location_from,
        location_to,
        driver,
        tacking_Place_at,
        transport_limit
    )
VALUES
    (?, ?, ?, ?, ?, ?)
`

type RidesCreateEventParams struct {
	RideID         string `json:"rideId"`
	LocationFrom   string `json:"locationFrom"`
	LocationTo     string `json:"locationTo"`
	Driver         string `json:"driver"`
	TackingPlaceAt string `json:"tackingPlaceAt"`
	TransportLimit int64  `json:"transportLimit"`
}

func (q *Queries) RidesCreateEvent(ctx context.Context, arg RidesCreateEventParams) error {
	_, err := q.db.ExecContext(ctx, ridesCreateEvent,
		arg.RideID,
		arg.LocationFrom,
		arg.LocationTo,
		arg.Driver,
		arg.TackingPlaceAt,
		arg.TransportLimit,
	)
	return err
}

const ridesCreateSchedule = `-- name: RidesCreateSchedule :one
INSERT INTO
    ride_schedules (ride_id, INTERVAL, unit)
VALUES
    (?, ?, ?) RETURNING id
`

type RidesCreateScheduleParams struct {
	RideID   string `json:"rideId"`
	Interval int64  `json:"interval"`
	Unit     string `json:"unit"`
}

func (q *Queries) RidesCreateSchedule(ctx context.Context, arg RidesCreateScheduleParams) (string, error) {
	row := q.db.QueryRowContext(ctx, ridesCreateSchedule, arg.RideID, arg.Interval, arg.Unit)
	var id string
	err := row.Scan(&id)
	return id, err
}

const ridesCreateScheduleWeekday = `-- name: RidesCreateScheduleWeekday :exec
INSERT INTO
    ride_schedule_weekdays (ride_schedule_id, weekday)
VALUES
    (?, ?)
`

type RidesCreateScheduleWeekdayParams struct {
	RideScheduleID string `json:"rideScheduleId"`
	Weekday        string `json:"weekday"`
}

func (q *Queries) RidesCreateScheduleWeekday(ctx context.Context, arg RidesCreateScheduleWeekdayParams) error {
	_, err := q.db.ExecContext(ctx, ridesCreateScheduleWeekday, arg.RideScheduleID, arg.Weekday)
	return err
}

const ridesGetLatest = `-- name: RidesGetLatest :one
SELECT
    r.id AS ride_id,
    re.id AS ride_event_id,
    re.location_from,
    re.location_to,
    re.tacking_place_at,
    r.created_by,
    re.transport_limit,
    re.driver,
    re.status,
    ud.email AS driver_email,
    uc.email AS created_by_email,
    rs.id AS ride_schedule_id,
    rs.unit AS ride_schedule_unit,
    rs.interval AS ride_schedule_interval,
    r.location_from AS base_location_from,
    r.location_to AS base_location_to,
    r.transport_limit AS base_transport_limit,
    r.driver AS base_driver
FROM
    ride_events re
    INNER JOIN rides r ON re.id = r.id
    LEFT OUTER JOIN ride_schedules rs ON rs.ride_id = r.id
    INNER JOIN users ud ON r.driver = ud.id
    INNER JOIN users uc ON r.created_by = uc.id
WHERE
    re.ride_id = ?
    AND re.tacking_place_at = (
        SELECT
            MAX(tacking_place_at)
        FROM
            ride_events
        WHERE
            id = re.id
    )
`

type RidesGetLatestRow struct {
	RideID               string         `json:"rideId"`
	RideEventID          string         `json:"rideEventId"`
	LocationFrom         string         `json:"locationFrom"`
	LocationTo           string         `json:"locationTo"`
	TackingPlaceAt       string         `json:"tackingPlaceAt"`
	CreatedBy            string         `json:"createdBy"`
	TransportLimit       int64          `json:"transportLimit"`
	Driver               string         `json:"driver"`
	Status               string         `json:"status"`
	DriverEmail          string         `json:"driverEmail"`
	CreatedByEmail       string         `json:"createdByEmail"`
	RideScheduleID       sql.NullString `json:"rideScheduleId"`
	RideScheduleUnit     sql.NullString `json:"rideScheduleUnit"`
	RideScheduleInterval sql.NullInt64  `json:"rideScheduleInterval"`
	BaseLocationFrom     string         `json:"baseLocationFrom"`
	BaseLocationTo       string         `json:"baseLocationTo"`
	BaseTransportLimit   int64          `json:"baseTransportLimit"`
	BaseDriver           string         `json:"baseDriver"`
}

func (q *Queries) RidesGetLatest(ctx context.Context, rideID string) (RidesGetLatestRow, error) {
	row := q.db.QueryRowContext(ctx, ridesGetLatest, rideID)
	var i RidesGetLatestRow
	err := row.Scan(
		&i.RideID,
		&i.RideEventID,
		&i.LocationFrom,
		&i.LocationTo,
		&i.TackingPlaceAt,
		&i.CreatedBy,
		&i.TransportLimit,
		&i.Driver,
		&i.Status,
		&i.DriverEmail,
		&i.CreatedByEmail,
		&i.RideScheduleID,
		&i.RideScheduleUnit,
		&i.RideScheduleInterval,
		&i.BaseLocationFrom,
		&i.BaseLocationTo,
		&i.BaseTransportLimit,
		&i.BaseDriver,
	)
	return i, err
}

const ridesGetMany = `-- name: RidesGetMany :many
SELECT
    r.id AS ride_id,
    re.id AS ride_event_id,
    re.location_from,
    re.location_to,
    re.tacking_place_at,
    r.created_by,
    re.transport_limit,
    re.driver,
    re.status,
    ud.email AS driver_email,
    uc.email AS created_by_email,
    rs.id AS ride_schedule_id,
    rs.unit AS ride_schedule_unit,
    rs.interval AS ride_schedule_interval
FROM
    ride_events re
    INNER JOIN rides r ON re.ride_id = r.id
    LEFT OUTER JOIN ride_schedules rs ON rs.ride_id = r.id
    INNER JOIN users ud ON r.driver = ud.id
    INNER JOIN users uc ON r.created_by = uc.id
ORDER BY
    (
        SELECT
            ordering
        FROM
            ride_event_status_ordering
        WHERE
            status = re.status
    ),
    tacking_place_at DESC
LIMIT
    50
OFFSET
    ?
`

type RidesGetManyRow struct {
	RideID               string         `json:"rideId"`
	RideEventID          string         `json:"rideEventId"`
	LocationFrom         string         `json:"locationFrom"`
	LocationTo           string         `json:"locationTo"`
	TackingPlaceAt       string         `json:"tackingPlaceAt"`
	CreatedBy            string         `json:"createdBy"`
	TransportLimit       int64          `json:"transportLimit"`
	Driver               string         `json:"driver"`
	Status               string         `json:"status"`
	DriverEmail          string         `json:"driverEmail"`
	CreatedByEmail       string         `json:"createdByEmail"`
	RideScheduleID       sql.NullString `json:"rideScheduleId"`
	RideScheduleUnit     sql.NullString `json:"rideScheduleUnit"`
	RideScheduleInterval sql.NullInt64  `json:"rideScheduleInterval"`
}

func (q *Queries) RidesGetMany(ctx context.Context, offset int64) ([]RidesGetManyRow, error) {
	rows, err := q.db.QueryContext(ctx, ridesGetMany, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RidesGetManyRow
	for rows.Next() {
		var i RidesGetManyRow
		if err := rows.Scan(
			&i.RideID,
			&i.RideEventID,
			&i.LocationFrom,
			&i.LocationTo,
			&i.TackingPlaceAt,
			&i.CreatedBy,
			&i.TransportLimit,
			&i.Driver,
			&i.Status,
			&i.DriverEmail,
			&i.CreatedByEmail,
			&i.RideScheduleID,
			&i.RideScheduleUnit,
			&i.RideScheduleInterval,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ridesGetSchedule = `-- name: RidesGetSchedule :one
SELECT
    id,
    ride_id,
    INTERVAL,
    unit
FROM
    ride_schedules
WHERE
    ride_id = ?
`

func (q *Queries) RidesGetSchedule(ctx context.Context, rideID string) (RideSchedule, error) {
	row := q.db.QueryRowContext(ctx, ridesGetSchedule, rideID)
	var i RideSchedule
	err := row.Scan(
		&i.ID,
		&i.RideID,
		&i.Interval,
		&i.Unit,
	)
	return i, err
}

const ridesGetScheduleWeekdays = `-- name: RidesGetScheduleWeekdays :many
SELECT
    weekday
FROM
    ride_schedule_weekdays
WHERE
    ride_schedule_id = ?
`

func (q *Queries) RidesGetScheduleWeekdays(ctx context.Context, rideScheduleID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, ridesGetScheduleWeekdays, rideScheduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var weekday string
		if err := rows.Scan(&weekday); err != nil {
			return nil, err
		}
		items = append(items, weekday)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ridesMarkPastEventsDone = `-- name: RidesMarkPastEventsDone :exec
UPDATE ride_events
SET
    status = 'done'
WHERE
    status = 'upcoming'
    AND tacking_place_at <= ?
`

func (q *Queries) RidesMarkPastEventsDone(ctx context.Context, tackingPlaceAt string) error {
	_, err := q.db.ExecContext(ctx, ridesMarkPastEventsDone, tackingPlaceAt)
	return err
}
